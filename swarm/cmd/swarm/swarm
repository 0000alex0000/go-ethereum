#!/bin/bash

if [ "$SWARM_DOCKER_TAG" = "" ]; then export SWARM_DOCKER_TAG="arachnid/swarm:latest"; fi

# Local directory, for legacy commands involving the geth binary
if [ "$GETH_DIR" = "" ]; then
  if [ "$GOPATH" = "" ]; then echo "either GETH_DIR or GOPATH environment variable must be set"; exit 1; fi
  export GETH_DIR=$GOPATH/src/github.com/ethereum/go-ethereum
fi

CONTAINER_DATADIR="/swarm/data"
CONTAINER_SOCKET="$CONTAINER_DATADIR/geth.ipc"
GETH="/geth --datadir=$CONTAINER_DATADIR"

root=$SWARM_DIR
cmd=$1
shift

dir="$root/$network_id"

tmpdir=/tmp

function randomfile {
  dd if=/dev/urandom of=/dev/stdout bs=1024 count=$1 2>/dev/null
}

# swarm container 00 returns the id of the docker container for node n
function container {
  docker ps -a --filter="label=swarm" --filter="label=id=$1" --format="{{.ID}}"
}

# swarm containers returns the IDs of all docker containers for the swarm
function containers {
  docker ps -a --filter="label=swarm" --format="{{.ID}}"
}

# returns the node number of a container
function nodenum {
  docker inspect --format "{{.Config.Labels.id}}" $1
}

function dockerexec {
  id=$1
  shift
  if [ "$id" = "all" ]; then
    for containerid in $(containers); do
      docker exec -it $containerid $*
    done
  else
    docker exec -it $(container $id) $*
  fi
}

function dgeth {
  id=$1
  shift
  dockerexec $id $GETH $*
}

# swarm attach 00 brings up a console attached to a running instance
function attach {
  echo "attaching console to instance $id"
  dgeth $1 attach ipc:/$CONTAINER_SOCKET
 }

# swarm execute 00 runs the specified command in an instance
function execute {
  id=$1
  shift
  dgeth $id --exec "$*" attach ipc:/$CONTAINER_SOCKET
}

# swarm hive 00 displays the kademlia table of the given running instance
function hive {
  execute $1 'console.log(bzz.hive)'|grep -v undefined
}

# swarm log 00 shows the running tail logs of an instance
function log {
  id=$1
  shift
  echo "streaming logs for instance $id"
  docker logs -f $(container $id)
}

# display kademlia tables of istances
function monitor {
  if [ "$3" = "" ]; then
    id=$1
    period=$2
    while true; do
      hive $id
      sleep $period
    done
  else
    #TODO: FIXME
    node=$1
    id=$2
    period=$3
    while true; do
      remote-run $node swarm hive $id
      sleep $period
    done
  fi
}


# swarm cleanbzz 00 removes the bzz subdirectory for a given instance (all for every instance)
function cleanbzz {
  id=$1
  shift
  echo "remove bzz data for instance $id"
  dockerexec $id rm -rf /swarm/data/bzz
}

# swarm less/viewlog 00 displays the last (current) log for the given instance (in a pager)
function viewlog {
  id=$1
  shift
  echo "viewing logs for instance $id"
  docker logs $(container $id) | less
}

# display the swarm base account for an instance
function key {
  execute $1 eth.accounts[0]
}

function enode {
  containerid=$(container $1)
  ip=$(docker inspect --format="{{.NetworkSettings.IPAddress}}" $containerid)
  docker exec $containerid $GETH --exec='admin.nodeInfo.enode' attach ipc:/$CONTAINER_SOCKET |perl -pe "s/\[\:\:\]/$ip/ "
}

# swarm options 00 displays the docker command line options used to start the swarm
function rawoptions {
  id=$1
  shift

  options="--name=swarm_$id --label="swarm" --label="id=$id" $SWARM_DOCKER_TAG --nodiscover"
  echo -n $options
  echo $*
}

function options {
  echo "The command line options passed to 'docker run' are the following:"
  rawoptions $*
}

function startcontainer {
  containerid=$1
  shift
  id=$(nodenum $containerid)

  livenodes=$(docker ps --filter="label=swarm" --format="{{.ID}}")

  status=`docker inspect --format="{{.State.Status}}" $containerid`
  if [ "$status" = "running" ]; then
    echo "instance $(nodenum $containerid) already running"
    return
  fi

  docker start $containerid >/dev/null

  # wait until ready
  ((j=0))
  while true; do
    execute $id "net" >/dev/null 2>&1 && break
    sleep 1
    echo -n "."
    if ((j++>10)); then
      echo "instance $id failed to start"
      exit 1
    fi
  done

  # add other peers
  for othercontainerid in $livenodes; do
    otherid=$(nodenum $othercontainerid)
    otherenode=$(enode $otherid)
    execute $id "admin.addPeer($otherenode)" >/dev/null
  done
}

function start {
  id=$1
  shift

  if [ "$id" = "all" ]; then
    for containerid in $(containers); do
      startcontainer $containerid
      echo "started instance $(nodenum $containerid)"
    done
    echo "started all instances"
  else
    startcontainer $(container $id)
    echo "started instance $id"
  fi
}


# setup 00 creates the docker container for an instance
function setup {
  id=$1
  shift
  docker create $(rawoptions $id) >/dev/null
}

function stopcontainer {
  containerid=$1
  shift
  status=`docker inspect --format="{{.State.Status}}" $containerid`
  if [ "$status" = "running" ]; then
    echo "stopping instance $(nodenum $containerid)"
    docker stop $containerid >/dev/null
  fi  
}

# shuts down a running instance
function stop {
  id=$1
  shift
  if [ "$id" = "all" ]; then
    for containerid in $(containers); do
      stopcontainer $containerid
    done
  else
    stopcontainer $(container $id)
  fi
}

# swarm restart 00 calls stop and start
function restart {
  id=$1
  shift
  stop $id
  start $id $*
}

# swarm init X sets up and starts a new cluster
##########################################################
#
# IT WIPES THE DATABASE
#
##########################################################
function init {
  destroy all
  cluster $*
}

function destroy {
  id=$1
  shift
  stop $id
  if [ "$id" = "all" ]; then
    for containerid in $(containers); do
      docker rm $containerid
    done
  else
    containerid=$(container id)
    docker rm $containerid
  fi
}

# reset replaces a node with a blank instance
function reset {
  destroy $1
  setup $1
}

# swarm cluster N launches N nodes; 00 01 02 ...
function cluster {
  N=$1
  shift
  echo "launching cluster of $N instances"
  for ((i=0;i<N;++i)); do
    id=`printf "%02d" $i`
    setup $id $*
  done
  start all
}

# swarm needs instance keyfile destination
# tests if the content for the key is available for the intance
#
function needs {
  id=$1
  keyfile=$2

  target=$3
  dest=$tmpdir/down
  mkdir -p $dest
  file=$dest/`basename $target`
  rm -f $file
  echo -n "waiting for root hash in '$keyfile'..."
  while true; do
   if [ ! -z $keyfile ]; then
    break
   fi
   sleep 1
   echo -n "."
  done
  key=`cat $keyfile|tr -d \"`
  echo " => $key"
  download $id $key $dest && cmp --silent $file $target && echo "PASS" || echo "FAIL"
}

# swarm up 00 file uploads file via instances CLI
function up { #port, file
  echo "Upload file '$2' to node $1... " 1>&2
  file=`basename $2`
  /usr/bin/time -f "latency: %e" execute $1 "bzz.upload(\"$2\", \"$file\")"|tail -n1> /tmp/key
  cat /tmp/key
}

# swarm download 00 file download file via instances CLI
function download {
  echo "download '$2' from node $1 to '$3'"
  execute $1 "bzz.download(\"$2\", \"$3\")" >/dev/null
}

# swarm down issues bzz.get to download the content 10 attempts
function down {
  echo -n "Download hash '$2' from node $1... "
  while true; do
    execute $1 "bzz.get(\"$2\")" 2> /dev/null |grep -qil "status" && break
    sleep 1
    echo -n "."
    if ((i++>10)); then
      echo "not found"
      return
    fi
  done
  echo "found OK"
}

# live into about an instance
function status {
  echo -n "account balance:     "
  execute $1 'eth.getBalance(eth.accounts[0])'
  echo -n "swap contract balance:       "
  execute $1 "eth.getBalance(bzz.info.Swap.Contract)"
  echo -n "chequebook balance:  "
  execute $1 "chequebook.balance"
  echo -n "peer count:          "
  execute $1 'net.peerCount'
  echo -n "latest block number: "
  execute $1 "eth.blockNumber"
}

# display peers for an instance
function peers {
  execute $1 'admin.peers'
}

# configures the eth-net-intelligence-api network monitor
function netstatconf {
  group=$1
  N=`ls -1 -d $dir/data/* |wc -l`
  ip=`curl ipecho.net/plain 2>/dev/null;echo `
  ws_server="ws://146.185.130.117:3000"
  ws_secret=BZZ322
  conf="$dir/$group-$ip.netstat.json"

  echo "writing netstat conf for cluster $group-$ip ($N instances) -> $conf"

  echo -e "[" > $conf

  for ((i=0;i<$N;++i)); do
    id=`printf "%02d" $i`
    single_template="  {\n    \"name\"        : \"$group-$ip-$i\",\n    \"cwd\"         : \".\",\n    \"script\"      : \"app.js\",\n    \"log_date_format\"   : \"YYYY-MM-DD HH:mm Z\",\n    \"merge_logs\"    : false,\n    \"watch\"       : false,\n    \"exec_interpreter\"  : \"node\",\n    \"exec_mode\"     : \"fork_mode\",\n    \"env\":\n    {\n      \"NODE_ENV\"    : \"production\",\n      \"RPC_HOST\"    : \"localhost\",\n      \"RPC_PORT\"    : \"302$id\",\n      \"INSTANCE_NAME\"   : \"$group-$ip-$i\",\n      \"WS_SERVER\"     : \"$ws_server\",\n      \"WS_SECRET\"     : \"$ws_secret\",\n    }\n  }"

    endline=""
    if ((i<$N-1)); then
    # if [ "$i" -ne "$N" ]; then
        endline=","
    fi
    echo -e "$single_template$endline" >> $conf
  done
  echo "]" >> $conf
}

# (re)starts the eth-net-intelligence-api network monitor
function netstatrun {
  cd $GETH_DIR/../eth-net-intelligence-api
  pm2 kill
  pm2 start $dir/*.netstat.json
}

# kills the eth-net-intelligence-api network monitor
function netstatkill {
  cd $GETH_DIR/../eth-net-intelligence-api
  pm2 kill
}

# copies the swarm control script to the remote node(s)
function remote-update-scripts {
  scriptdir=$GETH_DIR/swarm/cmd/swarm/
  remotes=$1
  for remote in `cat $remotes|grep -v '^#'`; do echo "updating scripts on $remote..."; ssh $remote mkdir -p bin && scp -r $scriptdir/* $remote:bin/; done
}

# copies the geth executable to the  remote nodes
function remote-update-bin {
  remotes=$1
  # remote-update-scripts $remotes
  for remote in `cat $remotes|grep -v '^#'`; do  echo "updating binary on $remote..."; scp -r $GETH_DIR/geth $remote:bin/; done
}

# runs a command on remote node or nodes from a file
function remote-run {
  remotes=$1
  shift
  if `echo "$remotes" | grep -qil @`; then
    ip=`echo "$remotes"|cut -d@ -f2`
    ssh $remotes "export IP_ADDR=$ip;" '. $HOME/bin/env.sh;' "$*"
  else
    for remote in `cat $remotes|grep -v '^#'`; do echo "running on $remote..."; remote-run $remote "$*"; done
  fi
}

# updates the code from the given branch
function update {
  branch=$1
  echo "cd $GETH_DIR &&  git remote update && git reset --hard $branch"
  (cd $GETH_DIR &&  git remote update && git reset --hard $branch)
}

function checksum {
  tar -cf - $1 | md5sum|awk '{print $1}'
}

function checkaccess {
  nodes=$1
  target=`basename $2`
  chsum=`md5sum $2|cut -f1 -d' '`
  master=`head  -1 $nodes`
  echo "uploading target on $master (md5sum $chsum, size: `du -b -d0 $2|cut -f1`)"
  scp $2 $master:$target
  hash=`swarm remote-run $master "swarm up 00 $target $file"|tr -d '"'`
  remote-run $nodes swarm checkdownload all $hash $chsum
}

function checkdownload {
  id=$1
  if [ "$id" = "all"  ]; then
    shift
    N=`ls -1 -d $dir/data/* |wc -l`
    for ((i=0;i<N;++i)); do
      id=`printf "%02d" $i`
      checkdownload $id $*
    done
  else
    hash=$2
    target=$3
    datetag=`date "+%Y-%m-%d-%H:%M:%S"`
    file="swarm-$datetag"
    rm -rf $tmpdir/$file
    /usr/bin/time -o $tmpdir/$file.log -f "%e" swarm download $id $hash $tmpdir/$file > /dev/null
    echo
    if [ -f $target ]; then
      cmp --silent  $target $tmpdir/$file/* && echo PASS || echo FAIL
    elif [ -r $target ]; then
      diff -r $target $tmpdir/$file/ >/dev/null && echo PASS || echo FAIL
    else
      exp=`md5sum $tmpdir/$file/*|cut -f1 -d' '`
      if [ "$exp" = "$target" ]; then
        echo -n  PASS
      else
        echo FAIL "$exp = $target"
      fi
    fi
    echo " latency: " `cat $tmpdir/$file.log`
  fi
}

function meminfo {
  pid="$dir/pids/$1.pid"
  if [ -f "$pid" ]; then
    # cd  /proc/`cat "$pid"` && cat status
    ps aux|awk -v PID=`cat $pid` '$2 == PID {print $5 "Kb (" $4 "%)" }'
  fi
}

function cpuinfo {
  pid="$dir/pids/$1.pid"
  if [ -f "$pid" ]; then
    # cd  /proc/`cat "$pid"` && cat status
   ps aux|awk -v PID=`cat $pid`  '$2  == PID {print $3 "%" }'
 fi
}

function diskusage {
  if [ "$1" == "" ]; then
    echo "DISK USAGE:" `df -m |grep '/$'|awk '{print $(NF-2) "Mb (" $(NF-1) ")"} '`
  else
    du -m -d0 $*|cut -f1
  fi
}

function diskinfo {
  echo "DISK USAGE $1:"
  echo "blockchain:" `diskusage $dir/data/$1/chaindata`
  echo "chunkstore:" `diskusage $dir/data/$1/bzz/*/chunks`
  echo "overall:  /"  `diskusage`
}

case $cmd in
  "container" )
    container $*;;
  "containers" )
    containers;;
  "info" )
    info $*;;
  "enode" )
    enode $*;;
  "status" )
    status $*;;
  "peers" )
    peers $*;;
  "needs" )
    needs $*;;
  "up" )
    up $*;;
  "key" )
    key $*;;
  "down" )
    down $*;;
  "download" )
    download $*;;
  "init" )
    init $*;;
  "exec" )
    execute $*;;
  "hive" )
    hive $*;;
  "start" )
    start $*;;
  "stop" )
    stop $* ;;
  "restart" )
    restart $*;;
  "destroy" )
    destroy $*;;
  "reset" )
    reset $*;;
  "cluster" )
    cluster $*;;
  "attach" )
    attach $*;;
  "execute" )
    execute $*;;
  "exec" )
    execute $*;;
  "cleanbzz" )
    cleanbzz $*;;
  "log" )
    log $*;;
  "viewlog" )
    viewlog $*;;
  "less" )
    viewlog $*;;
  "monitor" )
    monitor $*;;
  "remote-update-scripts" )
    remote-update-scripts $*;;
  "remote-update-bin" )
    remote-update-bin $*;;
  "update-src" )
    update-src $*;;
  "remote-run" )
    remote-run $*;;
  "netstatconf" )
    netstatconf  $*;;
  "netstatkill" )
    netstatkill  $*;;
  "netstatrun" )
    netstatrun  $*;;
  "options" )
    options $*;;
  "rawoptions" )
    rawoptions $*;;
  "randomfile" )
    randomfile $*;;
  "diskinfo" )
    diskinfo $*;;
  "meminfo" )
    meminfo $*;;
  "cpuinfo" )
    cpuinfo $*;;
  "setup" )
    setup $* ;;
  "create-account" )
    create-account $*;;
  "checkaccess" )
    checkaccess $* ;;
  "checkdownload" )
    checkdownload $* ;;
esac
